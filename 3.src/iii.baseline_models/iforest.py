# -*- coding: utf-8 -*-
"""iForest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18zP91DzqK8F6BlBoR2QhCzeXrXo8v5hO
"""

!pip install -q torch torch_geometric

import time
import torch
import numpy as np
import joblib
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import IsolationForest
from sklearn.metrics import (
    accuracy_score, precision_score, recall_score, f1_score,
    roc_auc_score, matthews_corrcoef, confusion_matrix
)

BASE_DIR = Path('/content/drive/MyDrive/ColabNotebooks/AnomalyDetection')
SPLIT_GRAPHS_BASE_DIR = BASE_DIR / 'graphs'
BASELINE_SAVE_DIR = BASE_DIR / 'baseline_models'
BASELINE_SAVE_DIR.mkdir(parents=True, exist_ok=True)

FINAL_MODEL_PATH = BASELINE_SAVE_DIR / 'iforest_baseline.joblib'

def flatten_graphs(graph_list):
    flat_data = []
    labels = []
    for g in graph_list:
        if g.x.numel() == 0: continue
        pooled_features = g.x.mean(dim=0).cpu().numpy()
        flat_data.append(pooled_features)
        labels.append(g.y.item())
    return np.array(flat_data), np.array(labels)

print("Loading Graph Data for Isolation Forest Baseline...")
try:
    train_graphs = torch.load(SPLIT_GRAPHS_BASE_DIR / 'train_graphs_benign.pt', weights_only=False)
    val_graphs = torch.load(SPLIT_GRAPHS_BASE_DIR / 'val_graphs_benign.pt', weights_only=False)
    test_graphs = torch.load(SPLIT_GRAPHS_BASE_DIR / 'test_graphs_mixed.pt', weights_only=False)

    print("Flattening graphs into vectors...")
    X_train, y_train = flatten_graphs(train_graphs + val_graphs)
    X_test, y_test = flatten_graphs(test_graphs)

    print(f"Train Data Shape: {X_train.shape}")
    print(f"Test Data Shape:  {X_test.shape}")

except FileNotFoundError:
    print(f"Error: Graph files not found at {SPLIT_GRAPHS_BASE_DIR}")
    exit()

iforest = IsolationForest(n_estimators=100, max_samples='auto', contamination='auto', random_state=42)

start_train = time.time()
iforest.fit(X_train)

train_time = time.time() - start_train
print(f"Training finished in {train_time:.2f} seconds.")

joblib.dump(iforest, FINAL_MODEL_PATH)
print(f"Model saved to: {FINAL_MODEL_PATH}")

start_inf = time.time()

preds_raw = iforest.predict(X_test)
inf_time = time.time() - start_inf

preds = np.where(preds_raw == -1, 1, 0)

scores = -iforest.score_samples(X_test)

cm = confusion_matrix(y_test, preds)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Predicted Benign', 'Predicted Attack'],
            yticklabels=['Actual Benign', 'Actual Attack'])
#plt.title('One-Class SVM Confusion Matrix (Baseline)')
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

acc = accuracy_score(y_test, preds)
prec = precision_score(y_test, preds)
rec = recall_score(y_test, preds)
f1 = f1_score(y_test, preds)
mcc = matthews_corrcoef(y_test, preds)
auc = roc_auc_score(y_test, scores)

print(f"=== RESULTS FOR ISOLATION FOREST =============")
print(f"Accuracy:       {acc:.4f}")
print(f"Precision:      {prec:.4f}")
print(f"Recall:         {rec:.4f}")
print(f"F1-Score:       {f1:.4f}")
print(f"MCC:            {mcc:.4f}")
print(f"ROC AUC:        {auc:.4f}")
print(f"Training Time:  {train_time:.4f} s")
print(f"Inference Time: {inf_time:.4f} s")
print("===============================================")